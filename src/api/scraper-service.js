/**
 * Servicio de Scraping - Ejecuta el scraping de PJUD de forma program√°tica
 * 
 * ‚ö†Ô∏è STANDARD COMPLIANCE: This service now delegates to processCausa engine.
 * See docs/scraping-standard.md for the single-engine rule.
 * 
 * This module is an ADAPTER that:
 * - Accepts API-style config
 * - Converts to ScrapingConfig format
 * - Calls processCausa (the engine)
 * - Post-processes results (DB persistence, HTTP response formatting)
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');

const { startBrowser } = require('../browser');
const { goToConsultaCausas } = require('../navigation');
const { processCausa } = require('../process-causas');

// Servicio de base de datos (opcional, si est√° configurado)
let dbService = null;
try {
  dbService = require('./db-service');
} catch (e) {
  console.log('[scraper] db-service no disponible, guardando solo en archivos');
}

/**
 * Convierte un archivo PDF a base64
 */
function pdfToBase64(filePath) {
  try {
    if (!fs.existsSync(filePath)) {
      return null;
    }
    const fileBuffer = fs.readFileSync(filePath);
    return fileBuffer.toString('base64');
  } catch (error) {
    console.error(`Error convirtiendo PDF a base64: ${error.message}`);
    return null;
  }
}

/**
 * Ejecuta el scraping completo de una causa
 * 
 * ‚ö†Ô∏è DELEGATES TO processCausa ENGINE - See docs/scraping-standard.md
 * 
 * @param {Object} config - Configuraci√≥n del scraping
 * @param {string} config.rit - RIT de la causa (ej: "C-16707-2019")
 * @param {string} config.competencia - ID de competencia (ej: "3")
 * @param {string} config.corte - ID de corte (ej: "90")
 * @param {string} config.tribunal - ID de tribunal (ej: "276")
 * @param {string} config.tipoCausa - Tipo de causa (ej: "C")
 * @param {boolean} config.headless - Si debe ejecutarse en modo headless (default: false)
 * 
 * @returns {Object} Resultado del scraping con movimientos y PDFs en base64
 */
async function ejecutarScraping(config) {
  const {
    rit,
    competencia,
    corte,
    tribunal,
    tipoCausa,
    headless = false
  } = config;

  // Validar campos requeridos
  if (!rit || !competencia || !corte || !tribunal || !tipoCausa) {
    throw new Error('Faltan campos requeridos: rit, competencia, corte, tribunal, tipoCausa');
  }

  // Verificar OJV_URL
  if (!process.env.OJV_URL) {
    throw new Error('OJV_URL no est√° configurada en .env');
  }

  // Convertir API config al formato ScrapingConfig que espera processCausa
  const ritParts = rit.split('-');
  const scrapingConfig = {
    rit,
    competencia: String(competencia),
    corte: String(corte),
    tribunal: String(tribunal),
    tipoCausa,
    rol: ritParts.length >= 2 ? ritParts[1] : null,
    a√±o: ritParts.length >= 3 ? ritParts[2] : null,
    caratulado: config.caratulado || null,
    cliente: config.cliente || null,
    rut: config.rut || null,
    abogado_id: config.abogado_id || null,
    cuenta_id: config.cuenta_id || null,
    causa_id: config.causa_id || null,
    agenda_id: config.agenda_id || null
  };

  const outputDir = path.resolve(__dirname, '../outputs');
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  console.log(`üöÄ Iniciando scraping para RIT: ${rit} (via processCausa engine)`);
  
  const { browser, context, page } = await startBrowser(process.env.OJV_URL, { headless });

  try {
    // ‚úÖ DELEGATE TO ENGINE: Use processCausa for all scraping
    await goToConsultaCausas(page);
    
    const resultado = await processCausa(page, context, scrapingConfig, outputDir);
    
    if (!resultado.success) {
      throw new Error(resultado.error || 'Error desconocido en scraping');
    }

    // Post-process: Read the JSON generated by processCausa
    const ritClean = rit.replace(/[^a-zA-Z0-9]/g, '_');
    const jsonPath = path.join(outputDir, 'causas', `${ritClean}.json`);
    
    let payload = null;
    if (fs.existsSync(jsonPath)) {
      payload = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));
    } else {
      throw new Error(`JSON generado por processCausa no encontrado en: ${jsonPath}`);
    }
    
    console.log(`üíæ Resultados guardados en ${outputDir}`);

    // Convertir PDFs del pdf_mapping a base64 para la API
    const pdfsBase64 = {};
    const pdfDir = path.join(outputDir, 'pdf');
    
    if (payload.pdf_mapping) {
      for (const [indice, mapping] of Object.entries(payload.pdf_mapping)) {
        if (mapping.azul) {
          const pdfPath = typeof mapping.azul === 'string' 
            ? path.join(pdfDir, mapping.azul)
            : mapping.azul;
          if (fs.existsSync(pdfPath)) {
            const base64 = pdfToBase64(pdfPath);
            if (base64) {
              pdfsBase64[path.basename(pdfPath)] = base64;
            }
          } else if (mapping.azul_base64) {
            // Si ya est√° en base64 en el mapping, usarlo directamente
            pdfsBase64[`${ritClean}_mov_${indice}_azul.pdf`] = mapping.azul_base64;
          }
        }
        if (mapping.rojo) {
          const pdfPath = typeof mapping.rojo === 'string' 
            ? path.join(pdfDir, mapping.rojo)
            : mapping.rojo;
          if (fs.existsSync(pdfPath)) {
            const base64 = pdfToBase64(pdfPath);
            if (base64) {
              pdfsBase64[path.basename(pdfPath)] = base64;
            }
          } else if (mapping.rojo_base64) {
            pdfsBase64[`${ritClean}_mov_${indice}_rojo.pdf`] = mapping.rojo_base64;
          }
        }
      }
    }
    
    // Preparar resultado en formato API
    const resultado = {
      rit,
      fecha_scraping: new Date().toISOString(),
      movimientos: payload.movimientos || [],
      cabecera: payload.cabecera || {},
      pdfs: pdfsBase64,
      total_movimientos: payload.metadata?.total_movimientos || 0,
      total_pdfs: Object.keys(pdfsBase64).length,
      estado: 'completado'
    };
    
    console.log(`‚úÖ Scraping completado: ${resultado.total_movimientos} movimientos, ${resultado.total_pdfs} PDFs`);

    // Guardar en base de datos si est√° disponible
    if (dbService) {
      try {
        await dbService.guardarMovimientos(
          rit,
          payload.movimientos || [],
          payload.cabecera || {},
          pdfsBase64
        );
        console.log(`üíæ Datos guardados en base de datos`);
        resultado.guardado_en_db = true;
      } catch (dbError) {
        console.warn(`‚ö†Ô∏è No se pudo guardar en BD: ${dbError.message}`);
        resultado.guardado_en_db = false;
        resultado.db_error = dbError.message;
      }
    }

    return resultado;
    
  } catch (error) {
    console.error(`‚ùå Error en scraping: ${error.message}`);
    throw error;
  } finally {
    await browser.close();
  }
}

module.exports = { ejecutarScraping };